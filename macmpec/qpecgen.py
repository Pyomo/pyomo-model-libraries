#  ___________________________________________________________________________
#
#  Pyomo: Python Optimization Modeling Objects
#  Copyright (c) 2008-2025
#  National Technology and Engineering Solutions of Sandia, LLC
#  Under the terms of Contract DE-NA0003525 with National Technology and
#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
#  rights in this software.
#  This software is distributed under the 3-clause BSD License.
#  ___________________________________________________________________________

# qpecgen.py QQR2-MN-v-v
# Original Pyomo coding by William Hart.
# Adapted from AMPL coding by Sven Leyffer, University of Dundee, Feb 2001.
#
# AMPL file which implements QPs generated by QPECgen.
#
# Reference: H. Jiang and D. Ralph, "QPECgen: A MATLAB generator for 
# mathematical programs with quadratic objectives and affine variational
# inequality constraints", Computational Optimization and Applications.
#
#
# The problems generated here are LCP constrained QPs (i.e. type 300)
# of the form
#
#   min 0.5*(x,y)'*P*(x,y) + c'x + d'y
#   s.t.    A*(x,y) + a <= 0        (1)
#       F(x,y) = N*x + M*y + q >= 0
#       y >= 0
#       F(x,y)*y = 0
#
#       # variables # constraints   degree of degeneracy
# data files    n_x n_y m_1 m_2 deg_1   deg_2   deg_m
# -------------------------------------------------------------------
# qpeq-100-1     5  100 2   0   1   20  20
# qpeq-100-2    10  100 2   0   1   20  20
# qpeq-100-3    10  100 4   0   1   20  20
# qpeq-100-4    20  100 4   0   1   20  20
# qpeq-200-1    10  200 4   0   2   40  40
# qpeq-200-2    20  200 4   0   2   40  40
# qpeq-200-3    20  200 8   0   2   40  40
# qpeq-200-4    40  200 8   0   2   40  40

import pyomo.environ
from pyomo.core import *
from pyomo.mpec import *


model = AbstractModel()

# ... dimension of QPEC
model.n_x = Param(within=Integers)   # ... dimension of x
model.n_y = Param(within=Integers)   # ... dimension of y
model.m_1 = Param(within=Integers)   # ... number of upper level constraints

# ... some useful sets
model.N_x = RangeSet(1, model.n_x)
model.N_y = RangeSet(1, model.n_y)
model.M_1 = RangeSet(1, model.m_1)

# ... data for QPEC instance
model.Pxx = Param(model.N_x, model.N_x)
model.Pxy = Param(model.N_x, model.N_y)
model.Pyy = Param(model.N_y, model.N_y)
model.c = Param(model.N_x)
model.d = Param(model.N_y)
model.Ax = Param(model.M_1, model.N_x)
model.Ay = Param(model.M_1, model.N_y, default=0)
model.a = Param(model.M_1)
model.N = Param(model.N_y, model.N_x)
model.M = Param(model.N_y, model.N_y)
model.q = Param(model.N_y)

# ... definition of variables
model.x = Var(model.N_x)
model.y = Var(model.N_y, within=NonNegativeReals)

# ... problem statement
def f_(model):
    return 0.5*( sum( x[i] * sum(Pxx[i,j]*x[j] for j in model.N_x) for i in model.N_x) ) \
            + 0.5*( sum( y[i] * sum(Pyy[i,j]*y[j] for j in model.N_y) for i in model.N_y) ) \
            +     ( sum( x[i] * sum(Pxy[i,j]*y[j] for j in model.N_y) for i in model.N_x) ) \
            + sum(x[i]*c[i] for i in model.N_x) \
            + sum(y[i]*d[i] for i in model.N_y)
model.f = Objective(rule=f_)

def Acon_(model, i):
    return sum(model.Ax[i,j]*model.x[j]  for j in model.N_x) \
                   + sum(model.Ay[i,j]*model.y[j] for j in model.N_y) + model.a[i] <= 0
model.Acon = Constraint(model.M_1, rule=Acon_)

def Fcon_(model, i):
    return complements(0 <= model.y[i],
                model.q[i] + sum(model.N[i,j]*model.x[j] for j in model.N_x) \
                             + sum(model.M[i,j]*model.y[j] for j in model.N_y) >= 0)
model.Fcon = Complementarity(model.N_y, rule=Fcon_)


